// prisma/schema.prisma
// prisma/schema.prisma
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  SUPER_ADMIN
  CLIENT_ADMIN
  WORKER
}

enum TimeEventType {
  CLOCK_IN
  BREAK_START
  BREAK_END
  CLOCK_OUT
}

enum AbsenceStatus {
  PENDING
  APPROVED
  REJECTED
}

enum AbsenceType {
  VACATION
  SICK_LEAVE
  PAID_LEAVE
  UNPAID_LEAVE
  JUSTIFIED_OTHER
  UNJUSTIFIED
}

enum CorrectionState {
  PENDING_SYSTEM_INSERT // (Simulado por un trabajo programado)
  PENDING_ADMIN_REVIEW // Sistema insertó salida, Admin debe revisar/aprobar corrección
  PENDING_WORKER_INPUT // Admin aprobó, trabajador debe ingresar hora
  COMPLETED // Corrección finalizada
  REJECTED // Admin rechazó la corrección
}

model Company {
  id          String   @id @default(uuid())
  name        String
  taxId       String?  // CIF/NIF
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users            User[]
  timeEvents       TimeEvent[]
  dailySummaries   TimeDailySummary[]
  absenceRequests  AbsenceRequest[]
  auditLogs        AuditLog[]
  holidays         CompanyHoliday[]
missingClockOuts MissingClockOut[]
}

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  fullName     String?
  role         Role     @default(WORKER)
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  // NUEVOS CAMPOS
  workStartMinutes Int?  // minutos desde 00:00, ej: 9*60 = 540 → 09:00
  workEndMinutes   Int?  // minutos desde 00:00, ej: 17*60 = 1020 → 17:00
  workDays         String?
  company   Company? @relation(fields: [companyId], references: [id])
  companyId String?

  timeEvents      TimeEvent[]
  dailySummaries  TimeDailySummary[]
  absenceRequests AbsenceRequest[]
  auditLogs       AuditLog[]

missingClockOuts        MissingClockOut[] @relation("WorkerRelation")
  reviewedMissingClockOuts MissingClockOut[] @relation("AdminRelation")
}

model TimeEvent {
  id         String        @id @default(uuid())
  type       TimeEventType
  timestamp  DateTime      @default(now())
  reason     String?
  company   Company @relation(fields: [companyId], references: [id])
  companyId String

  user   User   @relation(fields: [userId], references: [id])
  userId String
}

model TimeDailySummary {
  id               String   @id @default(uuid())
  date             DateTime
  workedMinutes    Int      @default(0)
  breakMinutes     Int      @default(0)
  overtimeMinutes  Int      @default(0)
  status           String   // COMPLETE, MISSING_EVENTS, NO_DATA...

  company   Company @relation(fields: [companyId], references: [id])
  companyId String

  user   User   @relation(fields: [userId], references: [id])
  userId String

  @@unique([userId, date])
}

model AbsenceRequest {
  id             String         @id @default(uuid())
  requestedType  AbsenceType    // lo que el usuario propone (excepto UNJUSTIFIED si quieres)
  finalType      AbsenceType?   // lo que decide el admin (puede ser UNJUSTIFIED)
  startDate      DateTime
  endDate        DateTime
  status         AbsenceStatus  // PENDING / APPROVED / REJECTED
  reason         String?
  adminComment   String?
  attachmentUrl  String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  company   Company @relation(fields: [companyId], references: [id])
  companyId String

  user   User   @relation(fields: [userId], references: [id])
  userId String
}

model AuditLog {
  id          String   @id @default(uuid())
  entityType  String
  entityId    String
  action      String   // CREATE, UPDATE, DELETE
  oldValue    Json?
  newValue    Json?
  createdAt   DateTime @default(now())

  company   Company? @relation(fields: [companyId], references: [id])
  companyId String?

  user   User?   @relation(fields: [userId], references: [id])
  userId String?
}

model CompanyHoliday {
  id        String   @id @default(uuid())
  date      DateTime
  name      String
  isPaid    Boolean  @default(true) // opcional: festivo retribuido o no
  company   Company  @relation(fields: [companyId], references: [id])
  companyId String

  createdAt DateTime @default(now())
  @@unique([companyId, date])
  
}

model MissingClockOut {
  id               String            @id @default(uuid())
  date             DateTime          // Fecha de la jornada con el fichaje faltante
  status           CorrectionState   @default(PENDING_ADMIN_REVIEW)
  provisionalTime  DateTime?         // Hora de salida predefinida por el sistema (ej: 17:00)
  manualTime       DateTime?         // Hora de salida final ingresada por el trabajador
  reason           String?           // Motivo de la corrección (ingresado por el trabajador)
  adminNotes       String?           // Notas/instrucciones del administrador
  
  company          Company           @relation(fields: [companyId], references: [id])
  companyId        String
  
  worker           User              @relation("WorkerRelation", fields: [workerId], references: [id])
  workerId         String
  
  adminApprover    User?             @relation("AdminRelation", fields: [adminApproverId], references: [id])
  adminApproverId  String?
  
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  @@unique([workerId, date])
}
